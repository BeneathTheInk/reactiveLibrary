<!DOCTYPE html>

<html>
<head>
	<title>D: The Reactive Library</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
	<link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
	<div id="container">
		<div id="background"></div>
		
		<ul class="sections">
				
				
				
				<li id="section-1">
						<div class="annotation">
							
							<div class="pilwrap for-h1">
								<a class="pilcrow" href="#section-1">&#182;</a>
							</div>
							<h1>D: The Reactive Library</h1>
<hr>

						</div>
						
				</li>
				
				
				<li id="section-2">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-2">&#182;</a>
							</div>
							<p>This library has three hard dependencies: <a href="http://backbonejs.org/">Backbone</a>, <a href="http://documentcloud.github.io/underscore">Underscore</a> and <a href="https://github.com/broofa/node-uuid">node-uuid</a>. While made for the Node.js environment, this library is compatible with the client using browserify.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>Backbone = require <span class="string">"backbone"</span>
_ = require <span class="string">"underscore"</span>
uuid = require <span class="string">"uuid"</span></pre></div></div>
						
				</li>
				
				
				<li id="section-3">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-3">&#182;</a>
							</div>
							<h2>The Major Variable</h2>

						</div>
						
				</li>
				
				
				<li id="section-4">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-4">&#182;</a>
							</div>
							<p>The variable <code>d</code> is global variable to access this library. <code>d</code> itself is actually a function that wraps <code>d.run()</code> for quick context set up and data retrieval. See <code>d.run()</code> for more info.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d = () -&gt; d.run.apply d, arguments
module.exports = d <span class="comment"># public api</span></pre></div></div>
						
				</li>
				
				
				<li id="section-5">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-5">&#182;</a>
							</div>
							<h2>Global Model</h2>

						</div>
						
				</li>
				
				
				<li id="section-6">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-6">&#182;</a>
							</div>
							<p>D setups a new Backbone model to house all of the application data. Data might include standard JavaScript variable types or Backbone models and collections. This allows for data to be accessible globally without affecting what it can do. You shouldn&#39;t access this model directly; instead use <code>d.get()</code> and <code>d.set()</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.model = <span class="keyword">new</span> Backbone.Model()</pre></div></div>
						
				</li>
				
				
				<li id="section-7">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-7">&#182;</a>
							</div>
							<h2>Subscriptions</h2>

						</div>
						
				</li>
				
				
				<li id="section-8">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-8">&#182;</a>
							</div>
							<p>Subscriptions are a connection between a path and multiple contexts. A subscription is created the first time it is requested and is then subscribed to each context that needs it.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.subs =
	subscriptions: []
	queue: [] <span class="comment"># to automate get subscription setup</span></pre></div></div>
						
				</li>
				
				
				<li id="section-9">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-9">&#182;</a>
							</div>
							<p><code>d.subs.create()</code> creates a new subscription at <code>path</code> with <code>data</code>. If the subscription already exists, any new data replaces the existing. The created subscription will be attached to a queue that can be accessed later. This method <em>does not</em> subscribe data to any context, but sets up the methods to do so.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	create: (path, data, ext = {}) -&gt;
		sub = <span class="property">@find</span> path

		<span class="keyword">unless</span> sub
			sub =
				id: uuid.v4()
				path: path
				data: data
				contexts: []
			
			_.extend sub, ext
			_.defaults sub, _.pick d, [ <span class="string">"subscribe"</span>, <span class="string">"unsubscribe"</span> ]
			
			subscribe = ext.subscribe <span class="keyword">or</span> d.subscribe
			unsubscribe = ext.unsubscribe <span class="keyword">or</span> d.unsubscribe

			sub.<span class="function"><span class="title">subscribe</span></span> = (ctx, options) -&gt;
				subscribe.apply @, arguments
				<span class="property">@contexts</span>.push ctx
				
				<span class="keyword">if</span> ext.temporary
					onstop = () =&gt; d.subs.remove <span class="property">@id</span>
					ctx.<span class="literal">on</span> <span class="string">"stop"</span>, onstop
					ctx.<span class="literal">on</span> <span class="string">"run:before"</span>, onstop

			sub.<span class="function"><span class="title">unsubscribe</span></span> = (ctx, options) -&gt;
				unsubscribe.apply @, arguments
				<span class="property">@contexts</span> = _.without <span class="property">@contexts</span>, ctx

			<span class="property">@subscriptions</span>.push sub

		<span class="keyword">else</span> <span class="keyword">unless</span> _.isEqual data, sub.data
			ctxs = sub.contexts

			_.each ctxs, (ctx) -&gt; sub.unsubscribe ctx <span class="comment"># unsubscribe from current data</span>
			sub.contexts = []
			sub.data = data <span class="comment"># Set current data</span>
			_.each ctxs, (ctx) -&gt; sub.subscribe ctx <span class="comment"># resubscribe to new data</span>
		
		<span class="property">@queue</span>.push sub
		<span class="keyword">return</span> sub</pre></div></div>
						
				</li>
				
				
				<li id="section-10">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-10">&#182;</a>
							</div>
							<p><code>d.subs.find()</code> turns a <code>path</code> or subscription <code>id</code> into a subscription. This is useful for subscription maintenance, including subscribing and unsubscribing from contexts.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	find: (path) -&gt;
		<span class="keyword">return</span> _.find <span class="property">@subscriptions</span>, (sub) -&gt;
			<span class="keyword">return</span> sub.path <span class="keyword">is</span> path <span class="keyword">or</span> sub.id <span class="keyword">is</span> path</pre></div></div>
						
				</li>
				
				
				<li id="section-11">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-11">&#182;</a>
							</div>
							<p><code>d.subs.remove()</code> completely removes a subscription from existence. All subscribed contexts are unsubscribed. </p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	remove: (id) -&gt;
		<span class="keyword">return</span> <span class="keyword">unless</span> sub = <span class="property">@find</span> id
		_.each sub.contexts, (ctx) -&gt; sub.unsubscribe ctx
		index = _.indexOf <span class="property">@subscriptions</span>, sub
		<span class="property">@subscriptions</span>.splice index, <span class="number">1</span>
	
	clear: () -&gt; <span class="property">@queue</span> = []</pre></div></div>
						
				</li>
				
				
				<li id="section-12">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-12">&#182;</a>
							</div>
							<h2>Using Data</h2>

						</div>
						
				</li>
				
				
				<li id="section-13">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-13">&#182;</a>
							</div>
							<p><code>d.get()</code> is a simple function that does many things. The first task of <code>d.get()</code> is to retrieve data at <code>path</code>. A <code>path</code> is a string of parts separated by a <code>.</code>. Each part refers a level of the data within <code>d.model</code>. For example, a path like <code>_session.foo.bar</code> would be resolved as <code>d.model.get(&quot;_session&quot;)[&quot;foo&quot;][&quot;bar&quot;]</code>.</p>
<p><code>d.get()</code> sets up a special starting path part <code>$</code>. This path will <em>always</em> refer to the global model even when the context is scoped.</p>
<p>The second thing <code>d.get()</code> does is set up the specified data as a subscription and subscribes it to the current context. Whenever a &quot;change&quot; to data is detected, the context will be rerun.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">get</span></span> = (path, options = {}) -&gt;
	ctx = <span class="property">@current</span>
	base = <span class="property">@_trim</span> (<span class="keyword">if</span> ctx <span class="keyword">then</span> ctx.path) <span class="keyword">or</span> <span class="string">""</span>
	parts = <span class="property">@_parts</span> path, base
	val = <span class="property">@retrieve</span> parts, options

	<span class="keyword">if</span> options.reactive <span class="keyword">isnt</span> <span class="literal">false</span> <span class="keyword">and</span> ctx <span class="comment"># subscribe path to ctx</span>
		d.subs.clear() <span class="comment"># we need a clean space</span>
		<span class="property">@process</span> val, parts, options <span class="comment"># process path into subscription</span>
		_.each d.subs.queue, (sub) -&gt; ctx.subscribe sub <span class="comment"># start subscription</span>
		d.subs.clear() <span class="comment"># clean again</span>

	<span class="keyword">return</span> <span class="keyword">if</span> val? <span class="keyword">then</span> val <span class="keyword">else</span> options.<span class="reserved">default</span></pre></div></div>
						
				</li>
				
				
				<li id="section-14">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-14">&#182;</a>
							</div>
							<p><code>d.set()</code>, on the other hand, sets data at <code>path</code>. <code>d.set()</code> is dynamic enough to translate a string path into a series of models and collections so the right value is always set. This will also automatically resubscribe to any data if the subscription was changed.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">set</span></span> = (path, value, options = {}) -&gt;
	parts = <span class="property">@_parts</span> path
	<span class="property">@update</span> parts, value, options</pre></div></div>
						
				</li>
				
				
				<li id="section-15">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-15">&#182;</a>
							</div>
							<h2>Reactive Contexts</h2>

						</div>
						
				</li>
				
				
				<li id="section-16">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-16">&#182;</a>
							</div>
							<p><code>d.reactive()</code> takes a function <code>fn</code> to be rerun any time a dependency changes. A dependency is simply any data returned from <code>d.get()</code>. <code>fn</code> will have <code>this</code> pointing to the reactive context. It is given no arguments and expects no return value. <code>d.reactive()</code> returns a &quot;reactive context&quot; which is simply a wrapper function for <code>fn</code>.</p>
<p>A neat feature of contexts is their ability to be nested within each other. Any time a parent context is run, all children contexts are stopped and restarted.</p>
<p>A reactive context must be called at least once to initiate its subscriptions. In this way, contexts are highly transportable and can be placed in more than one location, including multiple parent contexts. The context will automatically clean up after itself, only completely stopping when <em>all</em> parent contexts have also been stopped.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">reactive</span></span> = (fn, options = {}) -&gt;
	self = <span class="keyword">this</span>

	rfn = () -&gt;
		<span class="keyword">if</span> rfn.running <span class="keyword">then</span> <span class="keyword">return</span>

		parent = self.current <span class="comment"># cache the parent</span>
		self.current = rfn <span class="comment"># set the ctx</span>

		<span class="keyword">if</span> parent <span class="keyword">and</span> !_.contains rfn.parents, parent.id <span class="comment"># first run</span>
			rfn.parents.push(parent.id)

			onstop = () -&gt;
				rfn.parents = _.without rfn.parents, parent.id
				<span class="keyword">unless</span> rfn.parents.length <span class="keyword">or</span> rfn.root <span class="keyword">then</span> rfn.stop()

			parent.<span class="literal">on</span> <span class="string">"stop"</span>, onstop
			parent.<span class="literal">on</span> <span class="string">"run:before"</span>, onstop

			rfn.trigger <span class="string">"start"</span>
		
		<span class="keyword">unless</span> parent <span class="keyword">then</span> rfn.root = <span class="literal">true</span> <span class="comment"># make sure we don't stop suddenly</span>
		
		rfn.trigger <span class="string">"run:before"</span> <span class="comment"># pre run</span>
		rfn.running = <span class="literal">true</span>

		fn.call rfn <span class="comment"># run</span>

		rfn.trigger <span class="string">"run"</span> <span class="comment"># post run</span>
		rfn.running = <span class="literal">false</span>
		rfn.trigger <span class="string">"run:after"</span>

		self.current = parent <span class="comment"># reset the ctx</span></pre></div></div>
						
				</li>
				
				
				<li id="section-17">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-17">&#182;</a>
							</div>
							<p>The context also triggers events using Backbone&#39;s event API. These events include <code>start</code>, <code>run:before</code>, <code>run</code>, <code>run:after</code>, and <code>stop</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	_.extend rfn, Backbone.Events <span class="comment"># eventful</span></pre></div></div>
						
				</li>
				
				
				<li id="section-18">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-18">&#182;</a>
							</div>
							<p>Some notable properties of a reactive context include a globally unique id and a base path for scoping. A scoped context requires shorter paths to access the same data. For example, if there is a model at the path <code>Projects.1</code> and the context is scoped to it, any further paths will access the model directly. So <code>Project.1.title</code> becomes just <code>title</code>. Remember the global model can always be accessed with the path <code>$</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	rfn.id = uuid.v4() <span class="comment"># unique ctx id</span>
	rfn.path = options.path <span class="comment"># base path</span></pre></div></div>
						
				</li>
				
				
				<li id="section-19">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-19">&#182;</a>
							</div>
							<p>Each context defines a <code>subscribe()</code> and <code>unsubscribe()</code> method. These methods take a subscription and watch (or unwatch) for changes to data. Given the same arguments, <code>unsubscribe()</code> should &quot;undo&quot; anything done by <code>subscribe()</code>. Each subscription will only be subscribed to once.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	rfn.<span class="function"><span class="title">subscribe</span></span> = (sub, options = {}) -&gt;
		<span class="keyword">return</span> <span class="keyword">if</span> _.contains <span class="property">@subscriptions</span>, sub.id
		sub.subscribe @, options <span class="comment"># enable the subscription</span>
		<span class="property">@subscriptions</span>.push sub.id

	rfn.<span class="function"><span class="title">unsubscribe</span></span> = (sub, options = {}) -&gt;
		<span class="keyword">if</span> _.isString(sub) <span class="keyword">then</span> sub = self.subs.find sub
		<span class="keyword">return</span> <span class="keyword">unless</span> _.contains <span class="property">@subscriptions</span>, sub.id
		sub.unsubscribe @, options
		<span class="property">@subscriptions</span> = _.without <span class="property">@subscriptions</span>, sub.id</pre></div></div>
						
				</li>
				
				
				<li id="section-20">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-20">&#182;</a>
							</div>
							<p>Contexts also have a stop method that halts the context completely. All subscriptions are unsubscribed and the context is brought to a normalized state. A context can be restarted by calling it again.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	rfn.<span class="function"><span class="title">stop</span></span> = (o = {}) -&gt;
		_.each <span class="property">@subscriptions</span>, (id) =&gt; <span class="property">@unsubscribe</span> id
		reset()
		<span class="property">@trigger</span> <span class="string">"stop"</span>

	reset = () -&gt;
		rfn.subscriptions = []
		rfn.parents = [] <span class="comment"># parent ctxs</span>
		rfn.root = <span class="literal">false</span>

	reset()
	<span class="keyword">return</span> rfn</pre></div></div>
						
				</li>
				
				
				<li id="section-21">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-21">&#182;</a>
							</div>
							<h2>Useful Utilities</h2>

						</div>
						
				</li>
				
				
				<li id="section-22">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-22">&#182;</a>
							</div>
							<p><code>d.run()</code> is the marriage of <code>d.get()</code> and <code>d.reactive()</code> in a simple package. If just a <code>path</code> is given, <code>d.get()</code> is used to retrieve the data and set up subscriptions. If <code>fn</code> is given, a reactive context is created. If <code>fn</code> is used with <code>path</code>, the context is scoped to <code>path</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">run</span></span> = (path, fn, options) -&gt;
	<span class="keyword">if</span> _.isObject(fn) <span class="keyword">and</span> !_.isFunction(fn) <span class="keyword">and</span> !options <span class="keyword">then</span> [options, fn] = [fn, <span class="literal">null</span>]
	<span class="keyword">if</span> _.isFunction(path) <span class="keyword">and</span> !fn <span class="keyword">then</span> [fn, path] = [path, <span class="literal">null</span>]
	options ?= {}

	<span class="keyword">if</span> _.isFunction(fn)
		<span class="keyword">if</span> path <span class="keyword">then</span> _.extend options, { path: path }
		(r = <span class="property">@reactive</span>(fn, options))()
		<span class="keyword">return</span> r
	<span class="keyword">else</span> <span class="keyword">return</span> <span class="property">@get</span> path, options</pre></div></div>
						
				</li>
				
				
				<li id="section-23">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-23">&#182;</a>
							</div>
							<p><code>d.depend()</code> forces the current context to subscribe to <code>data</code>. This allows contexts to subscribe to <code>data</code> even if <code>data</code> doesn&#39;t exist in <code>d.model</code>. It creates a temporary subscription that is destroyed on context close. This method is hackable.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">depend</span></span> = (data, options = {}) -&gt;
	<span class="keyword">if</span> ctx = <span class="property">@current</span>
		sub = <span class="property">@subs</span>.create uuid.v4(), { obj: data, subpath: <span class="literal">null</span> }, { temporary: <span class="literal">true</span> }
		ctx.subscribe sub, options
		d.subs.clear() <span class="comment"># clean up</span>
		<span class="keyword">return</span></pre></div></div>
						
				</li>
				
				
				<li id="section-24">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-24">&#182;</a>
							</div>
							<h2>Hackable Methods</h2>

						</div>
						
				</li>
				
				
				<li id="section-25">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-25">&#182;</a>
							</div>
							<p>Several methods within this library are &quot;hackable&quot; and can be modified. This is useful for when core data needs to be controlled by something other than Backbone or context specific functionality is desired.</p>
<hr>

						</div>
						
				</li>
				
				
				<li id="section-26">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-26">&#182;</a>
							</div>
							<p><code>d.retrieve()</code> is responsible for getting the value at path. <code>parts</code> is an array of path partitions, always relative to <code>d.model</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">retrieve</span></span> = (parts, options = {}) -&gt;
	cur = <span class="property">@model</span>

	<span class="keyword">if</span> _.some(parts, (p) =&gt;
		<span class="keyword">unless</span> _.isObject(cur) <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">true</span>
		<span class="keyword">else</span> <span class="keyword">if</span> <span class="property">@_isBackboneData</span>(cur) <span class="keyword">then</span> cur = cur.get(p)
		<span class="keyword">else</span> cur = cur[p]
		<span class="keyword">return</span> <span class="literal">false</span>
	) <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">undefined</span>

	<span class="keyword">return</span> cur</pre></div></div>
						
				</li>
				
				
				<li id="section-27">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-27">&#182;</a>
							</div>
							<p><code>d.update()</code> sets a <code>value</code> at path. It also handles the firing of update events so reactive contexts can be rerun.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">update</span></span> = (parts, value, options = {}) -&gt;
	lo = <span class="property">@model</span>
	cur = <span class="property">@model</span>
	path = []

	_.each parts, (p) =&gt;
		<span class="keyword">if</span> <span class="property">@_isBackboneData</span>(cur)
			lo = cur
			cur = cur.get(p)
			path = []
		<span class="keyword">else</span> <span class="keyword">if</span> _.isObject(cur)
			cur = cur[p]
		
		path.push p

	rp = _.rest path
	child = lo.get path[<span class="number">0</span>]

	<span class="keyword">if</span> rp.length
		<span class="keyword">unless</span> _.isObject(child) <span class="keyword">then</span> child = {}
		<span class="keyword">else</span> child = _.clone child
		<span class="property">@_deep</span> child, rp.join(<span class="string">"."</span>), value
	<span class="keyword">else</span> child = value

	lo.set path[<span class="number">0</span>], child</pre></div></div>
						
				</li>
				
				
				<li id="section-28">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-28">&#182;</a>
							</div>
							<p><code>d.process()</code> sets up subscriptions given a <code>value</code> and path <code>parts</code>. This should <strong>only</strong> create subscriptions, not subscribe them to any contexts. Even though this function will be rerun multiple times for the same subscriptions, the API will not duplicate subscriptions.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">process</span></span> = (value, parts, options = {}) -&gt;
	obj = <span class="property">@model</span>
	base = <span class="string">""</span>
	paths = []
	subpath = []

	<span class="function"><span class="title">add</span></span> = (part) -&gt;
		<span class="keyword">if</span> _.isEmpty(base) <span class="keyword">then</span> base = part
		<span class="keyword">else</span> base += <span class="string">"."</span> + part

	flush = () =&gt;
		<span class="keyword">if</span> subpath.length <span class="keyword">then</span> add subpath[<span class="number">0</span>] <span class="comment"># backbone isnt deep, we only want the first one</span>
		<span class="property">@subs</span>.create base, { obj: obj, subpath: subpath[<span class="number">0</span>] <span class="keyword">or</span> <span class="literal">null</span> }, options
		subpath = []

	_.each parts, (p) =&gt;
		paths.push p
		val = <span class="property">@retrieve</span> paths
		subpath.push p

		<span class="keyword">if</span> <span class="property">@_isBackboneData</span> val
			flush() <span class="comment"># flush the cache</span>
			obj = val <span class="comment"># set the major object</span>

	flush() <span class="comment"># flush one last time</span></pre></div></div>
						
				</li>
				
				
				<li id="section-29">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-29">&#182;</a>
							</div>
							<p><code>d.subscribe()</code> is the default subscribe method used by subscriptions. <code>this</code> within the method will refer to the subscription using it. By passing <code>fn</code>, this method should set the proper events to call the context any time it needs to update.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">subscribe</span></span> = (fn, options = {}) -&gt;
	data = <span class="property">@data</span>.obj
	subpath = <span class="property">@data</span>.subpath

	<span class="keyword">if</span> _.isEqual(data, d.model) <span class="keyword">and</span> !subpath <span class="keyword">then</span> <span class="keyword">return</span>
	<span class="keyword">else</span> <span class="keyword">if</span> data <span class="keyword">instanceof</span> Backbone.Model
		attr = <span class="keyword">if</span> subpath <span class="keyword">then</span> <span class="string">":"</span> + subpath <span class="keyword">else</span> <span class="string">""</span>
		fn.listenTo data, <span class="string">"change"</span>+attr, fn
	<span class="keyword">else</span> <span class="keyword">if</span> data <span class="keyword">instanceof</span> Backbone.Collection
		fn.listenTo data, <span class="string">"add"</span>, fn
		fn.listenTo data, <span class="string">"remove"</span>, fn
		fn.listenTo data, <span class="string">"sort"</span>, fn</pre></div></div>
						
				</li>
				
				
				<li id="section-30">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-30">&#182;</a>
							</div>
							<p><code>d.unsubscribe()</code> is the default unsubscribe method used by subscriptions. It is called in the same fashion as <code>d.subscribe()</code>. Given the same arguments, it should completely reverse anything done by the subscribe method.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">unsubscribe</span></span> = (fn, options = {}) -&gt;
	data = <span class="property">@data</span>.obj
	subpath = <span class="property">@data</span>.subpath

	<span class="keyword">if</span> _.isEqual(data, d.model) <span class="keyword">and</span> !subpath <span class="keyword">then</span> <span class="keyword">return</span>
	<span class="keyword">else</span> <span class="keyword">if</span> d._isBackboneData(data) <span class="keyword">then</span> fn.stopListening data</pre></div></div>
						
				</li>
				
				
				<li id="section-31">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-31">&#182;</a>
							</div>
							<h2>Helpers</h2>

						</div>
						
				</li>
				
				
				<li id="section-32">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-32">&#182;</a>
							</div>
							<p><code>d._parts()</code> takes a string <code>path</code> and divides it into an array of path parts. Optionally pass <code>base</code> to prefix it to path in the event <code>$</code> is not use.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_parts</span></span> = (path, base) -&gt;
	path = d._trim path
	<span class="keyword">if</span> <span class="regexp">/^\$/.test(path) then path = path.replace /^\$\.?/</span>, <span class="string">""</span>
	<span class="keyword">else</span> <span class="keyword">if</span> base <span class="keyword">then</span> path = base + <span class="string">"."</span> + path
	<span class="keyword">return</span> _.compact <span class="property">@_keysplit</span> path</pre></div></div>
						
				</li>
				
				
				<li id="section-33">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-33">&#182;</a>
							</div>
							<p><code>d._keysplit()</code> takes a string and separates it by <code>sep</code>. You can use <code>sep</code> in the path by prefixing it with <code>avoid</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_keysplit</span></span> = (str, sep = <span class="string">"."</span>, avoid = <span class="string">"\\"</span>) -&gt;
	rawParts = str.split sep
	parts = []
	i = <span class="number">0</span>
	len = rawParts.length

	<span class="keyword">while</span> i &lt; len
		part = <span class="string">""</span>
		<span class="keyword">while</span> rawParts[i].slice(-<span class="number">1</span>) <span class="keyword">is</span> avoid
			part += rawParts[i++].slice(<span class="number">0</span>, -<span class="number">1</span>) + sep  
		parts.push part + rawParts[i]
		i++
	
	<span class="keyword">return</span> parts</pre></div></div>
						
				</li>
				
				
				<li id="section-34">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-34">&#182;</a>
							</div>
							<p><code>d._deep()</code> gets or sets a <code>value</code> at <code>key</code> deeply within an object. When setting a <code>value</code> and <code>key</code> doesn&#39;t exist, objects are created to make it fit.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_deep</span></span> = (obj, key, value) -&gt;
	keys = _.compact <span class="property">@_keysplit</span> key
	i = <span class="number">0</span>
	n = keys.length

	<span class="keyword">if</span> arguments.length &gt; <span class="number">2</span> <span class="comment"># set value</span>
		root = obj
		n--
		<span class="keyword">while</span> i &lt; n
			key = keys[i++]
			obj = obj[key] = (<span class="keyword">if</span> _.isObject(obj[key]) <span class="keyword">then</span> obj[key] <span class="keyword">else</span> {})
		obj[keys[i]] = value
		value = root

	<span class="keyword">else</span> <span class="comment"># get value</span>
		<span class="keyword">continue</span> <span class="keyword">while</span> (obj = obj[keys[i++]])? <span class="keyword">and</span> i &lt; n
		value = (<span class="keyword">if</span> i &lt; n <span class="keyword">then</span> <span class="literal">undefined</span> <span class="keyword">else</span> obj)
	
	<span class="keyword">return</span> value</pre></div></div>
						
				</li>
				
				
				<li id="section-35">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-35">&#182;</a>
							</div>
							<p><code>d._trim()</code> normalizes a path by removing any leading or trailing separators.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_trim</span></span> = (str, sep = <span class="string">"."</span>) -&gt;
	len = sep.length
	ss = () -&gt; String.prototype.substr.apply str, arguments
	<span class="keyword">while</span> ss(<span class="number">0</span>, len) <span class="keyword">is</span> sep <span class="keyword">then</span> str = ss len
	<span class="keyword">while</span> ss(-<span class="number">1</span> * len) <span class="keyword">is</span> sep <span class="keyword">then</span> str = ss <span class="number">0</span>, str.length - len
	<span class="keyword">return</span> str</pre></div></div>
						
				</li>
				
				
				<li id="section-36">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-36">&#182;</a>
							</div>
							<p><code>d._isBackboneData()</code> tests <code>obj</code> as a Backbone model or collection. Useful in determining if data can take events or needs to be accessed in a different way.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_isBackboneData</span></span> = (obj) -&gt;
	<span class="keyword">return</span> _.isObject(obj) <span class="keyword">and</span> (obj <span class="keyword">instanceof</span> Backbone.Model <span class="keyword">or</span> obj <span class="keyword">instanceof</span> Backbone.Collection)</pre></div></div>
						
				</li>
				
		</ul>
	</div>
</body>
</html>
