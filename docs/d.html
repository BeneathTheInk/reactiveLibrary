<!DOCTYPE html>

<html>
<head>
	<title>D: The Reactive Library</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
	<link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
	<div id="container">
		<div id="background"></div>
		
		<ul class="sections">
				
				
				
				<li id="section-1">
						<div class="annotation">
							
							<div class="pilwrap for-h1">
								<a class="pilcrow" href="#section-1">&#182;</a>
							</div>
							<h1>D: The Reactive Library</h1>
<hr>

						</div>
						
				</li>
				
				
				<li id="section-2">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-2">&#182;</a>
							</div>
							<p>This library has three hard dependencies: <a href="http://backbonejs.org/">Backbone</a>, <a href="http://documentcloud.github.io/underscore">Underscore</a> and <a href="https://github.com/broofa/node-uuid">node-uuid</a>. While made for the Node.js environment, this library is compatible with the client using browserify.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>Backbone = require <span class="string">"backbone"</span>
_ = require <span class="string">"underscore"</span>
uuid = require <span class="string">"uuid"</span></pre></div></div>
						
				</li>
				
				
				<li id="section-3">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-3">&#182;</a>
							</div>
							<h2>The Major Variable</h2>

						</div>
						
				</li>
				
				
				<li id="section-4">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-4">&#182;</a>
							</div>
							<p>The variable <code>d</code> is global variable to access this library. <code>d</code> itself is actually a function that wraps <code>d.run()</code> for quick context set up and data retrieval. See <code>d.run()</code> for more info.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d = () -&gt; d.run.apply d, arguments
module.exports = d <span class="comment"># public api</span></pre></div></div>
						
				</li>
				
				
				<li id="section-5">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-5">&#182;</a>
							</div>
							<h2>Global Model</h2>

						</div>
						
				</li>
				
				
				<li id="section-6">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-6">&#182;</a>
							</div>
							<p>D setups a new Backbone model to house all of the application data. Data might include standard JavaScript variable types or Backbone models and collections. This allows for data to be accessible globally without affecting what it can do. You shouldn&#39;t access this model directly; instead use <code>d.get()</code> and <code>d.set()</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.model = <span class="keyword">new</span> Backbone.Model()</pre></div></div>
						
				</li>
				
				
				<li id="section-7">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-7">&#182;</a>
							</div>
							<h2>Subscriptions</h2>

						</div>
						
				</li>
				
				
				<li id="section-8">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-8">&#182;</a>
							</div>
							<p>Subscriptions are a connection between a path and multiple contexts. A subscription is created the first time it is requested and is then subscribed to each context that needs it.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.subs =
	subscriptions: []
	queue: [] <span class="comment"># to automate get subscription setup</span></pre></div></div>
						
				</li>
				
				
				<li id="section-9">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-9">&#182;</a>
							</div>
							<p><code>d.subs.create()</code> creates a new subscription at <code>path</code> with <code>data</code>. If the subscription already exists, any new data replaces the existing. The created subscription will be attached to a queue that can be accessed later. This method <em>does not</em> subscribe data to any context, but sets up the methods to do so.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	create: (path, data, ext = {}) -&gt;
		sub = <span class="property">@find</span> path

		<span class="keyword">unless</span> sub
			sub =
				id: uuid.v4()
				path: path
				data: data
				contexts: []
			
			_.extend sub, Backbone.Events <span class="comment"># eventful</span>
			_.extend sub, ext
			
			sub.<span class="function"><span class="title">add</span></span> = (ctx, options) -&gt;
				<span class="property">@contexts</span>.push ctx
				<span class="keyword">if</span> ext.temporary <span class="keyword">then</span> ctx.cleanup () =&gt; d.subs.remove <span class="property">@id</span>

			sub.<span class="function"><span class="title">remove</span></span> = (ctx, options) -&gt;
				<span class="property">@contexts</span> = _.without <span class="property">@contexts</span>, ctx

			<span class="property">@subscriptions</span>.push sub

		<span class="keyword">else</span> <span class="keyword">unless</span> _.isEqual data, sub.data
			ctxs = sub.contexts

			_.each ctxs, (ctx) -&gt; ctx.unsubscribe sub <span class="comment"># unsubscribe from current data</span>
			sub.contexts = []
			sub.data = data <span class="comment"># Set current data</span>
			_.each ctxs, (ctx) -&gt; ctx.subscribe sub <span class="comment"># resubscribe to new data</span>
		
		<span class="property">@queue</span>.push sub
		<span class="keyword">return</span> sub</pre></div></div>
						
				</li>
				
				
				<li id="section-10">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-10">&#182;</a>
							</div>
							<p><code>d.subs.find()</code> turns a <code>path</code> or subscription <code>id</code> into a subscription. This is useful for subscription maintenance, including subscribing and unsubscribing from contexts.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	find: (path) -&gt;
		<span class="keyword">return</span> _.find <span class="property">@subscriptions</span>, (sub) -&gt;
			<span class="keyword">return</span> sub.path <span class="keyword">is</span> path <span class="keyword">or</span> sub.id <span class="keyword">is</span> path</pre></div></div>
						
				</li>
				
				
				<li id="section-11">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-11">&#182;</a>
							</div>
							<p><code>d.subs.remove()</code> completely removes a subscription from existence. All subscribed contexts are unsubscribed. </p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	remove: (id) -&gt;
		<span class="keyword">return</span> <span class="keyword">unless</span> sub = <span class="property">@find</span> id
		_.each sub.contexts, (ctx) -&gt; ctx.unsubscribe sub
		index = _.indexOf <span class="property">@subscriptions</span>, sub
		<span class="property">@subscriptions</span>.splice index, <span class="number">1</span>
	
	clear: () -&gt; <span class="property">@queue</span> = []</pre></div></div>
						
				</li>
				
				
				<li id="section-12">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-12">&#182;</a>
							</div>
							<h2>Using Data</h2>

						</div>
						
				</li>
				
				
				<li id="section-13">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-13">&#182;</a>
							</div>
							<p><code>d.get()</code> is a simple function that does many things. The first task of <code>d.get()</code> is to retrieve data at <code>path</code>. A <code>path</code> is a string of parts separated by a <code>.</code>. Each part refers a level of the data within <code>d.model</code>. For example, a path like <code>_session.foo.bar</code> would be resolved as <code>d.model.get(&quot;_session&quot;)[&quot;foo&quot;][&quot;bar&quot;]</code>.</p>
<p><code>d.get()</code> sets up a special starting path part <code>$</code>. This path will <em>always</em> refer to the global model even when the context is scoped.</p>
<p>The second thing <code>d.get()</code> does is set up the specified data as a subscription and subscribes it to the current context. Whenever a &quot;change&quot; to data is detected, the context will be rerun.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">get</span></span> = (path, options = {}) -&gt;
	ctx = <span class="property">@current</span>
	base = <span class="property">@_trim</span> (<span class="keyword">if</span> ctx <span class="keyword">then</span> ctx.path) <span class="keyword">or</span> <span class="string">""</span>
	parts = <span class="property">@_parts</span> path, base
	val = <span class="property">@retrieve</span> parts, options

	<span class="keyword">if</span> options.reactive <span class="keyword">isnt</span> <span class="literal">false</span> <span class="keyword">and</span> ctx <span class="comment"># subscribe path to ctx</span>
		d.subs.clear() <span class="comment"># we need a clean space</span>
		<span class="property">@process</span> val, parts, options <span class="comment"># process path into subscription</span>
		_.each d.subs.queue, (sub) -&gt; ctx.subscribe sub, options <span class="comment"># start subscription</span>
		d.subs.clear() <span class="comment"># clean again</span>

	<span class="keyword">return</span> <span class="keyword">if</span> val? <span class="keyword">then</span> val <span class="keyword">else</span> options.<span class="reserved">default</span></pre></div></div>
						
				</li>
				
				
				<li id="section-14">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-14">&#182;</a>
							</div>
							<p><code>d.set()</code>, on the other hand, sets data at <code>path</code>. <code>d.set()</code> is dynamic enough to translate a string path into a series of models and collections so the right value is always set. This will also automatically resubscribe to any data if the subscription was changed.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">set</span></span> = (path, value, options = {}) -&gt;
	parts = <span class="property">@_parts</span> path
	<span class="property">@update</span> parts, value, options</pre></div></div>
						
				</li>
				
				
				<li id="section-15">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-15">&#182;</a>
							</div>
							<h2>Reactive Contexts</h2>

						</div>
						
				</li>
				
				
				<li id="section-16">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-16">&#182;</a>
							</div>
							<p><code>d.reactive()</code> takes a function <code>fn</code> to be rerun any time a dependency changes. A dependency is simply any data returned from <code>d.get()</code>. <code>fn</code> will have <code>this</code> pointing to the reactive context. It is given no arguments and expects no return value. <code>d.reactive()</code> returns a &quot;reactive context&quot; which is simply a wrapper function for <code>fn</code>. A reactive context must be called at least once to initiate its subscriptions.</p>
<p>A neat feature of contexts is their ability to be nested within each other. Any time a parent context is run, all children contexts are stopped and restarted. Reactive contexts can only be placed within a single parent context. If a context is run within a context that isn&#39;t it&#39;s parent, closing events will not be received and memory will leak.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">reactive</span></span> = (fn, options = {}) -&gt;
	self = <span class="keyword">this</span>

	rfn = () -&gt;
		<span class="keyword">if</span> rfn.running <span class="keyword">then</span> <span class="keyword">return</span>
		rfn.running = <span class="literal">true</span>

		old = self.current <span class="comment"># cache the old context</span>
		self.current = rfn <span class="comment"># set the ctx</span>

		<span class="keyword">if</span> rfn.first_run
			rfn.parent = old <span class="comment"># cache parent on context creation</span></pre></div></div>
						
				</li>
				
				
				<li id="section-17">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-17">&#182;</a>
							</div>
							<p>clean up when parent does</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>			<span class="keyword">if</span> rfn.parent <span class="keyword">then</span> rfn.parent.cleanup rfn.stop.bind(rfn)

			rfn.trigger <span class="string">"start"</span>
			rfn.first_run = <span class="literal">false</span>

		rfn.trigger <span class="string">"run:before"</span> <span class="comment"># pre run</span>

		fn.call rfn <span class="comment"># run</span>

		rfn.trigger <span class="string">"run"</span> <span class="comment"># post run</span>
		rfn.trigger <span class="string">"run:after"</span>

		self.current = old <span class="comment"># reset the ctx</span>
		rfn.running = <span class="literal">false</span></pre></div></div>
						
				</li>
				
				
				<li id="section-18">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-18">&#182;</a>
							</div>
							<p>The context also triggers events using Backbone&#39;s event API. These events include <code>start</code>, <code>run:before</code>, <code>run</code>, <code>run:after</code>, and <code>stop</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	_.extend rfn, Backbone.Events <span class="comment"># eventful</span></pre></div></div>
						
				</li>
				
				
				<li id="section-19">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-19">&#182;</a>
							</div>
							<p>Some notable properties of a reactive context include a globally unique id and a base path for scoping. A scoped context requires shorter paths to access the same data. For example, if there is a model at the path <code>Projects.1</code> and the context is scoped to it, any further paths will access the model directly. So <code>Project.1.title</code> becomes just <code>title</code>. Remember the global model can always be accessed with the path <code>$</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	rfn.id = uuid.v4() <span class="comment"># unique ctx id</span>
	rfn.path = options.path <span class="comment"># base path</span></pre></div></div>
						
				</li>
				
				
				<li id="section-20">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-20">&#182;</a>
							</div>
							<p>Each context defines a <code>subscribe()</code> and <code>unsubscribe()</code> method. These methods take a subscription and watch (or unwatch) for changes to data. Given the same arguments, <code>unsubscribe()</code> should &quot;undo&quot; anything done by <code>subscribe()</code>. Each subscription will only be subscribed to once.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	rfn.<span class="function"><span class="title">subscribe</span></span> = (sub, o = {}) -&gt;
		<span class="keyword">return</span> <span class="keyword">if</span> _.contains <span class="property">@subscriptions</span>, sub.id
		<span class="keyword">return</span> <span class="keyword">if</span> _.contains <span class="property">@never</span>, sub.path
		subscribe = options.subscribe <span class="keyword">or</span> d.subscribe
		
		sub.add @, o <span class="comment"># tell the subscription about us</span>
		subscribe.call sub, @, o <span class="comment"># enable the subscription</span>
		<span class="property">@subscriptions</span>.push sub.id

	rfn.<span class="function"><span class="title">unsubscribe</span></span> = (sub, o = {}) -&gt;
		<span class="keyword">if</span> _.isString(sub) <span class="keyword">then</span> sub = self.subs.find sub
		<span class="keyword">return</span> <span class="keyword">unless</span> sub <span class="keyword">and</span> _.contains <span class="property">@subscriptions</span>, sub.id
		unsubscribe = options.unsubscribe <span class="keyword">or</span> d.unsubscribe
		
		sub.remove @, o
		unsubscribe.call sub, @, o <span class="comment"># disable subscription</span>
		<span class="property">@subscriptions</span> = _.without <span class="property">@subscriptions</span>, sub.id</pre></div></div>
						
				</li>
				
				
				<li id="section-21">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-21">&#182;</a>
							</div>
							<p>Sometimes children contexts will subscribe to data before the parent does causing the context to reload multiple times. Use <code>prevent()</code> will stop a context from <em>ever</em> subscribing to a specified path.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	rfn.<span class="function"><span class="title">prevent</span></span> = (p) -&gt;
		<span class="property">@never</span>.push p
		<span class="keyword">return</span> <span class="keyword">unless</span> sub = self.subs.find p
		<span class="property">@unsubscribe</span> sub

	reset = () -&gt;
		rfn.subscriptions = []
		rfn.never = []
		rfn.parent = <span class="literal">null</span>
		rfn.first_run = <span class="literal">true</span></pre></div></div>
						
				</li>
				
				
				<li id="section-22">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-22">&#182;</a>
							</div>
							<p>Contexts also have a stop method that halts the context completely. All subscriptions are unsubscribed and the context is brought to a normalized state. A context can be restarted by calling it again.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	rfn.<span class="function"><span class="title">stop</span></span> = (o = {}) -&gt;
		_.each <span class="property">@subscriptions</span>, (id) =&gt; <span class="property">@unsubscribe</span> id
		reset()
		<span class="property">@trigger</span> <span class="string">"stop"</span></pre></div></div>
						
				</li>
				
				
				<li id="section-23">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-23">&#182;</a>
							</div>
							<p>Reactive contexts come with an easy clean up utility that helps to run some function whenever the context is stopped or re-run. This is useful for deep contexts that need to be destroyed regularly.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>	rfn.<span class="function"><span class="title">cleanup</span></span> = (fn) -&gt;
		onstop = () =&gt;
			<span class="property">@off</span> <span class="string">"stop"</span>, onstop
			<span class="property">@off</span> <span class="string">"run:before"</span>, onstop
			fn()

		<span class="property">@on</span> <span class="string">"stop"</span>, onstop
		<span class="property">@on</span> <span class="string">"run:before"</span>, onstop

	reset()
	<span class="keyword">return</span> rfn</pre></div></div>
						
				</li>
				
				
				<li id="section-24">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-24">&#182;</a>
							</div>
							<h2>Useful Utilities</h2>

						</div>
						
				</li>
				
				
				<li id="section-25">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-25">&#182;</a>
							</div>
							<p><code>d.run()</code> is the marriage of <code>d.get()</code> and <code>d.reactive()</code> in a simple package. If just a <code>path</code> is given, <code>d.get()</code> is used to retrieve the data and set up subscriptions. If <code>fn</code> is given, a reactive context is created. If <code>fn</code> is used with <code>path</code>, the context is scoped to <code>path</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">run</span></span> = (path, fn, options) -&gt;
	<span class="keyword">if</span> _.isObject(fn) <span class="keyword">and</span> !_.isFunction(fn) <span class="keyword">and</span> !options <span class="keyword">then</span> [options, fn] = [fn, <span class="literal">null</span>]
	<span class="keyword">if</span> _.isFunction(path) <span class="keyword">and</span> !fn <span class="keyword">then</span> [fn, path] = [path, <span class="literal">null</span>]
	options ?= {}

	<span class="keyword">if</span> _.isFunction(fn)
		<span class="keyword">if</span> path <span class="keyword">then</span> _.extend options, { path: path }
		(r = <span class="property">@reactive</span>(fn, options))()
		<span class="keyword">return</span> r
	<span class="keyword">else</span> <span class="keyword">return</span> <span class="property">@get</span> path, options</pre></div></div>
						
				</li>
				
				
				<li id="section-26">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-26">&#182;</a>
							</div>
							<p><code>d.depend()</code> forces the current context to subscribe to <code>data</code>. This allows contexts to subscribe to <code>data</code> even if <code>data</code> doesn&#39;t exist in <code>d.model</code>. It creates a temporary subscription that is destroyed on context close. This method is hackable.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">depend</span></span> = (data, options = {}) -&gt;
	<span class="keyword">if</span> ctx = <span class="property">@current</span>
		sub = <span class="property">@subs</span>.create uuid.v4(), data, { temporary: <span class="literal">true</span> }
		ctx.subscribe sub, options
		d.subs.clear() <span class="comment"># clean up</span>
		<span class="keyword">return</span></pre></div></div>
						
				</li>
				
				
				<li id="section-27">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-27">&#182;</a>
							</div>
							<h2>Hackable Methods</h2>

						</div>
						
				</li>
				
				
				<li id="section-28">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-28">&#182;</a>
							</div>
							<p>Several methods within this library are &quot;hackable&quot; and can be modified. This is useful for when core data needs to be controlled by something other than Backbone or context specific functionality is desired.</p>
<hr>

						</div>
						
				</li>
				
				
				<li id="section-29">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-29">&#182;</a>
							</div>
							<p><code>d.retrieve()</code> is responsible for getting the value at path. <code>parts</code> is an array of path partitions, always relative to <code>d.model</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">retrieve</span></span> = (parts, options = {}) -&gt;
	cur = <span class="property">@model</span>

	<span class="keyword">if</span> _.some(parts, (p) =&gt;
		<span class="keyword">unless</span> _.isObject(cur) <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">true</span>
		<span class="keyword">else</span> <span class="keyword">if</span> <span class="property">@_isBackboneData</span>(cur) <span class="keyword">then</span> cur = cur.get(p)
		<span class="keyword">else</span> cur = cur[p]
		<span class="keyword">return</span> <span class="literal">false</span>
	) <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">undefined</span>

	<span class="keyword">return</span> cur</pre></div></div>
						
				</li>
				
				
				<li id="section-30">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-30">&#182;</a>
							</div>
							<p><code>d.update()</code> sets a <code>value</code> at path. It also handles the firing of update events so reactive contexts can be rerun.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">update</span></span> = (parts, value, options = {}) -&gt;
	lo = <span class="property">@model</span>
	cur = <span class="property">@model</span>
	path = []

	_.each parts, (p) =&gt;
		<span class="keyword">if</span> <span class="property">@_isBackboneData</span>(cur)
			lo = cur
			cur = cur.get(p)
			path = []
		<span class="keyword">else</span> <span class="keyword">if</span> _.isObject(cur)
			cur = cur[p]
		
		path.push p

	rp = _.rest path
	child = lo.get path[<span class="number">0</span>]

	<span class="keyword">if</span> rp.length
		<span class="keyword">unless</span> _.isObject(child) <span class="keyword">then</span> child = {}
		<span class="keyword">else</span> child = _.clone child
		<span class="property">@_deep</span> child, rp.join(<span class="string">"."</span>), value
	<span class="keyword">else</span> child = value

	lo.set path[<span class="number">0</span>], child, silent: <span class="literal">true</span> <span class="comment"># let backbone set, but we trigger the events</span>
	lo.trigger <span class="string">"change:<span class="subst">#{path[<span class="number">0</span>]}</span>"</span>, lo, child, options
	lo.trigger <span class="string">"change"</span>, lo, options</pre></div></div>
						
				</li>
				
				
				<li id="section-31">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-31">&#182;</a>
							</div>
							<p><code>d.process()</code> sets up subscriptions given a <code>value</code> and path <code>parts</code>. This should <strong>only</strong> create subscriptions, not subscribe them to any contexts. Even though this function will be rerun multiple times for the same subscriptions, the API will not duplicate subscriptions.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">process</span></span> = (value, parts, options = {}) -&gt;
	obj = <span class="property">@model</span>
	base = <span class="string">""</span>
	paths = []
	subpath = []

	<span class="function"><span class="title">add</span></span> = (part) -&gt;
		<span class="keyword">if</span> _.isEmpty(base) <span class="keyword">then</span> base = part
		<span class="keyword">else</span> base += <span class="string">"."</span> + part

	flush = () =&gt;
		<span class="property">@subs</span>.create base, obj
		_.each subpath, add
		subpath = []

	_.each parts, (p) =&gt;
		paths.push p
		val = <span class="property">@retrieve</span> paths
		subpath.push p

		<span class="keyword">if</span> <span class="property">@_isBackboneData</span> val
			flush() <span class="comment"># flush the cache</span>
			obj = val <span class="comment"># set the major object</span>

	flush() <span class="comment"># flush one last time</span></pre></div></div>
						
				</li>
				
				
				<li id="section-32">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-32">&#182;</a>
							</div>
							<p><code>d.subscribe()</code> is the default subscribe method used by subscriptions. <code>this</code> within the method will refer to the subscription using it. By passing <code>fn</code>, this method should set the proper events to call the context any time it needs to update.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">subscribe</span></span> = (fn, options = {}) -&gt;
	data = <span class="property">@data</span>
	
	<span class="keyword">if</span> data <span class="keyword">instanceof</span> Backbone.Model
		fn.listenTo data, <span class="string">"change"</span>, fn
	<span class="keyword">else</span> <span class="keyword">if</span> data <span class="keyword">instanceof</span> Backbone.Collection
		fn.listenTo data, <span class="string">"add"</span>, fn
		fn.listenTo data, <span class="string">"remove"</span>, fn
		fn.listenTo data, <span class="string">"sort"</span>, fn
		fn.listenTo data, <span class="string">"reset"</span>, fn</pre></div></div>
						
				</li>
				
				
				<li id="section-33">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-33">&#182;</a>
							</div>
							<p><code>d.unsubscribe()</code> is the default unsubscribe method used by subscriptions. It is called in the same fashion as <code>d.subscribe()</code>. Given the same arguments, it should completely reverse anything done by the subscribe method.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">unsubscribe</span></span> = (fn, options = {}) -&gt;
	<span class="keyword">if</span> d._isBackboneData(<span class="property">@data</span>) <span class="keyword">then</span> fn.stopListening <span class="property">@data</span></pre></div></div>
						
				</li>
				
				
				<li id="section-34">
						<div class="annotation">
							
							<div class="pilwrap for-h2">
								<a class="pilcrow" href="#section-34">&#182;</a>
							</div>
							<h2>Helpers</h2>

						</div>
						
				</li>
				
				
				<li id="section-35">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-35">&#182;</a>
							</div>
							
						</div>
						
				</li>
				
				
				<li id="section-36">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-36">&#182;</a>
							</div>
							<p><code>d.join()</code> takes any number of string arguments and concats them together to form a path.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">join</span></span> = () -&gt; _.chain(arguments).toArray().flatten().compact().map((p) -&gt; d._trim(p)).value().join(<span class="string">"."</span>)</pre></div></div>
						
				</li>
				
				
				<li id="section-37">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-37">&#182;</a>
							</div>
							<p><code>d._parts()</code> takes a string <code>path</code> and divides it into an array of path parts. Optionally pass <code>base</code> to prefix it to path in the event <code>$</code> is not use.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_parts</span></span> = (path, base) -&gt;
	path = d._trim path
	<span class="keyword">if</span> path <span class="keyword">is</span> <span class="string">"@"</span> <span class="keyword">then</span> path = base
	<span class="keyword">else</span> <span class="keyword">if</span> <span class="regexp">/^\$/.test(path) then path = path.replace /^\$\.?/</span>, <span class="string">""</span>
	<span class="keyword">else</span> <span class="keyword">if</span> base <span class="keyword">then</span> path = d.join base, path
	<span class="keyword">if</span> <span class="regexp">/^\$/.test(path) then path = path.replace /^\$\.?/</span>, <span class="string">""</span> <span class="comment"># remove excess from base</span>
	<span class="keyword">return</span> _.compact <span class="property">@_keysplit</span> path</pre></div></div>
						
				</li>
				
				
				<li id="section-38">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-38">&#182;</a>
							</div>
							<p><code>d._keysplit()</code> takes a string and separates it by <code>sep</code>. You can use <code>sep</code> in the path by prefixing it with <code>avoid</code>.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_keysplit</span></span> = (str, sep = <span class="string">"."</span>, avoid = <span class="string">"\\"</span>) -&gt;
	rawParts = str.split sep
	parts = []
	i = <span class="number">0</span>
	len = rawParts.length

	<span class="keyword">while</span> i &lt; len
		part = <span class="string">""</span>
		<span class="keyword">while</span> rawParts[i].slice(-<span class="number">1</span>) <span class="keyword">is</span> avoid
			part += rawParts[i++].slice(<span class="number">0</span>, -<span class="number">1</span>) + sep  
		parts.push part + rawParts[i]
		i++
	
	<span class="keyword">return</span> parts</pre></div></div>
						
				</li>
				
				
				<li id="section-39">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-39">&#182;</a>
							</div>
							<p><code>d._deep()</code> gets or sets a <code>value</code> at <code>key</code> deeply within an object. When setting a <code>value</code> and <code>key</code> doesn&#39;t exist, objects are created to make it fit.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_deep</span></span> = (obj, key, value) -&gt;
	keys = _.compact <span class="property">@_keysplit</span> key
	i = <span class="number">0</span>
	n = keys.length

	<span class="keyword">if</span> arguments.length &gt; <span class="number">2</span> <span class="comment"># set value</span>
		root = obj
		n--
		<span class="keyword">while</span> i &lt; n
			key = keys[i++]
			obj = obj[key] = (<span class="keyword">if</span> _.isObject(obj[key]) <span class="keyword">then</span> obj[key] <span class="keyword">else</span> {})
		obj[keys[i]] = value
		value = root

	<span class="keyword">else</span> <span class="comment"># get value</span>
		<span class="keyword">continue</span> <span class="keyword">while</span> (obj = obj[keys[i++]])? <span class="keyword">and</span> i &lt; n
		value = (<span class="keyword">if</span> i &lt; n <span class="keyword">then</span> <span class="literal">undefined</span> <span class="keyword">else</span> obj)
	
	<span class="keyword">return</span> value</pre></div></div>
						
				</li>
				
				
				<li id="section-40">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-40">&#182;</a>
							</div>
							<p><code>d._trim()</code> normalizes a path by removing any leading or trailing separators.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_trim</span></span> = (str, sep = <span class="string">"."</span>) -&gt;
	len = sep.length
	ss = () -&gt; String.prototype.substr.apply str, arguments
	<span class="keyword">while</span> ss(<span class="number">0</span>, len) <span class="keyword">is</span> sep <span class="keyword">then</span> str = ss len
	<span class="keyword">while</span> ss(-<span class="number">1</span> * len) <span class="keyword">is</span> sep <span class="keyword">then</span> str = ss <span class="number">0</span>, str.length - len
	<span class="keyword">return</span> str</pre></div></div>
						
				</li>
				
				
				<li id="section-41">
						<div class="annotation">
							
							<div class="pilwrap ">
								<a class="pilcrow" href="#section-41">&#182;</a>
							</div>
							<p><code>d._isBackboneData()</code> tests <code>obj</code> as a Backbone model or collection. Useful in determining if data can take events or needs to be accessed in a different way.</p>

						</div>
						
						<div class="content"><div class='highlight'><pre>d.<span class="function"><span class="title">_isBackboneData</span></span> = (obj) -&gt;
	<span class="keyword">return</span> _.isObject(obj) <span class="keyword">and</span> (obj <span class="keyword">instanceof</span> Backbone.Model <span class="keyword">or</span> obj <span class="keyword">instanceof</span> Backbone.Collection)</pre></div></div>
						
				</li>
				
		</ul>
	</div>
</body>
</html>
