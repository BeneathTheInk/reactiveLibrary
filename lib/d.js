// Generated by CoffeeScript 1.6.3
(function() {
  var Backbone, d, debug, _,
    __slice = [].slice;

  Backbone = require("backbone-deep-model");

  _ = require("underscore");

  d = function() {
    return d.run.apply(d, arguments);
  };

  module.exports = d;

  debug = function() {
    if (d.debug) {
      return console.log.apply(console, arguments);
    }
  };

  d.model = new Backbone.DeepModel;

  d.reactive = function(fn, options) {
    var reset, rfn, self;
    if (options == null) {
      options = {};
    }
    self = this;
    rfn = function() {
      return rfn.run();
    };
    rfn.id = _.uniqueId();
    rfn.path = options.path;
    _.extend(rfn, Backbone.Events);
    (reset = function() {
      return _.extend(rfn, {
        parent: null,
        prevented: [],
        firstRun: true,
        running: false,
        stopped: true
      });
    })();
    rfn.run = function() {
      var old,
        _this = this;
      if (this.running) {
        return;
      }
      this.running = true;
      this.stopped = false;
      old = self.current;
      self.current = rfn;
      if (this.firstRun) {
        this.parent = old || null;
        if (this.parent) {
          this.parent.cleanup(function() {
            return _this.stop();
          });
        }
        this.trigger("start");
        this.firstRun = false;
      }
      debug("started >", this.id);
      this.trigger("run:before");
      fn.call(rfn);
      this.trigger("run");
      this.trigger("run:after");
      debug("finished >", this.id);
      self.current = old;
      return this.running = false;
    };
    rfn.invalidate = function() {
      var _this = this;
      if (this.invalid) {
        return;
      }
      this.invalid = true;
      return setTimeout(function() {
        if (!_this.stopped) {
          _this.run();
        }
        _this.trigger("invalid");
        return _this.invalid = false;
      }, 0);
    };
    rfn.stop = function() {
      this.stopped = true;
      this.invalidate();
      this.trigger("stop");
      return reset();
    };
    rfn.cleanup = function(fn) {
      var onstop,
        _this = this;
      onstop = function() {
        _this.off("stop", onstop);
        _this.off("run:before", onstop);
        return fn();
      };
      this.on("stop", onstop);
      return this.on("run:before", onstop);
    };
    rfn.prevent = function(path) {
      if (!_.contains(this.prevented, path)) {
        return this.prevented.push(path);
      }
    };
    rfn.event = function(val, path, options) {
      if (_.contains(this.prevented, path)) {
        return;
      }
      return this.invalidate();
    };
    rfn.subscribe = function(path, options) {
      var parts, _ref;
      if (options == null) {
        options = {};
      }
      _ref = d._pathOrPart(path), path = _ref.path, parts = _ref.parts;
      debug("subscribing >", path);
      return d.bind("change:" + path, this.event, this);
    };
    rfn.unsubscribe = function(path, options) {
      var parts, _ref;
      if (options == null) {
        options = {};
      }
      _ref = d._pathOrPart(path), path = _ref.path, parts = _ref.parts;
      debug("unsubscribing >", path);
      return d.unbind("change:" + path, this.event);
    };
    return rfn;
  };

  d.get = function(path, options) {
    var ctx, parts, val, _ref;
    if (options == null) {
      options = {};
    }
    parts = d._parts(path);
    _ref = d._pathOrPart(parts), path = _ref.path, parts = _ref.parts;
    val = d.retrieve(parts, options);
    ctx = d.current;
    if (options.reactive !== false && ctx) {
      ctx.subscribe(path, options);
      ctx.cleanup(function() {
        return ctx.unsubscribe(path, options);
      });
    }
    return val;
  };

  d.retrieve = function(parts, options) {
    var cur, path, push, subpath, _parts;
    if (options == null) {
      options = {};
    }
    parts = d._pathOrPart(parts).parts;
    cur = d.model;
    _parts = [];
    path = [];
    subpath = [];
    push = function(data) {
      _parts.push({
        path: path,
        subpath: subpath,
        fullpath: d.join(path, subpath),
        data: cur
      });
      path = path.concat(subpath);
      subpath = [];
      return cur = data;
    };
    _.each(parts, function(part) {
      var val;
      subpath.push(part);
      val = cur.get(d.join(subpath));
      if (d._isBackboneData(val)) {
        return push(val);
      }
    });
    push();
    if (options.complex === true) {
      return _parts;
    } else {
      return d._complexToValue(_parts);
    }
  };

  d.set = function(path, value, options) {
    var mod, parts, _parts, _ref;
    if (options == null) {
      options = {};
    }
    _ref = d._pathOrPart(path), path = _ref.path, parts = _ref.parts;
    _parts = d.retrieve(parts, {
      complex: true
    });
    if (!(mod = _.last(_parts))) {
      return;
    }
    if (!(mod.subpath.length && _parts.length >= 2)) {
      mod = _.first(_.last(_parts, 2));
    }
    if (!mod.subpath.length) {
      return;
    }
    if (d._isBackboneData(value)) {
      value.on("all", d.event(path));
    }
    return mod.data.set(d.join(mod.subpath), value);
  };

  d.event = function(path) {
    return function() {
      var args, attr, event, fp, isBase, model, name, _ref;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _ref = d._eventParse(event), event = _ref.event, name = _ref.name, attr = _ref.attr;
      if (attr.substr(-1) === "*") {
        return;
      }
      isBase = _.isEmpty(attr);
      fp = d.join(path, attr);
      if (name === "change" && attr && this instanceof Backbone.Collection) {
        if (!(model = args[0])) {
          return;
        }
        fp = d.join(path, model.cid, attr);
      }
      debug("event >", "" + name + ":" + fp);
      d.trigger(fp, name, {
        isBase: isBase,
        args: args
      });
      if (name !== "change") {
        d.trigger(fp, "change", {
          isBase: true
        });
        if (!(model = args[0])) {
          return;
        }
        return d.trigger(d.join(fp, model.cid), "change", {
          isBase: false
        });
      }
    };
  };

  d.model.on("all", d.event(""));

  d._paths = {};

  d.bind = function(event, fn, context) {
    var attr, evts, name, _ref;
    if (!(_.isString(event) && _.isFunction(fn))) {
      return;
    }
    _ref = d._eventParse(event), event = _ref.event, name = _ref.name, attr = _ref.attr;
    if (!_.has(d._paths, attr)) {
      d._paths[attr] = {};
    }
    evts = d._paths[attr];
    if (!_.has(evts, name)) {
      evts[name] = [];
    }
    return evts[name].push({
      fn: fn,
      context: context
    });
  };

  d.unbind = function(event, fn) {
    var attr, evts, name, _ref;
    if (!_.isString(event)) {
      return;
    }
    _ref = d._eventParse(event), event = _ref.event, name = _ref.name, attr = _ref.attr;
    if (!_.isObject(evts = d._paths[attr])) {
      return;
    }
    if (!_.isFunction(fn)) {
      return delete evts[name];
    } else {
      return evts[name] = _.filter(evts[name], function(s) {
        return s.fn !== fn;
      });
    }
  };

  d.on = d.bind;

  d.off = d.unbind;

  _.extend(d, _.pick(Backbone.Events, "listenTo", "listenToOnce", "stopListening"));

  d.trigger = function(attr, name, options) {
    var base, evts, execFns, parts, path, subpath, _ref, _ref1;
    if (name == null) {
      name = "change";
    }
    if (options == null) {
      options = {};
    }
    if (_.isEmpty(parts = d.retrieve(d.split(attr), {
      complex: true
    }))) {
      return;
    }
    _ref = _.last(parts), subpath = _ref.subpath, path = _ref.path;
    _.defaults(options, {
      isBase: false,
      args: []
    });
    if (!options.isBase && _.isEmpty(subpath)) {
      if (parts.length < 2) {
        return;
      }
      _ref1 = _.first(_.last(parts, 2)), subpath = _ref1.subpath, path = _ref1.path;
    }
    execFns = function(subs, path) {
      var val;
      if (!_.isArray(subs)) {
        return;
      }
      val = d.retrieve(d.split(path));
      debug("exec > " + name + ":" + path);
      return _.each(subs, function(s) {
        var ctx;
        ctx = s.context || null;
        return s.fn.call(ctx, val, attr, options);
      });
    };
    if (name === "change") {
      if (options.isBase) {
        return _.each(d._paths, function(evts, p) {
          if (d._isChildOf(p, attr, true)) {
            return execFns(evts[name], p);
          }
        });
      } else {
        _.each(d._paths, function(evts, p) {
          if (d._isChildOf(attr, p)) {
            return execFns(evts[name], p);
          }
        });
        base = d.join(path);
        return _.each(subpath, function(p) {
          var evts;
          base = d.join(base, p);
          if (!_.isObject(evts = d._paths[base])) {
            return;
          }
          return execFns(evts[name], base);
        });
      }
    } else {
      if (!_.isObject(evts = d._paths[attr])) {
        return;
      }
      return execFns(evts[name], attr);
    }
  };

  d.run = function(path, fn, options) {
    var r, _ref, _ref1;
    if (_.isObject(fn) && !_.isFunction(fn) && !options) {
      _ref = [fn, null], options = _ref[0], fn = _ref[1];
    }
    if (_.isFunction(path) && !fn) {
      _ref1 = [path, null], fn = _ref1[0], path = _ref1[1];
    }
    if (options == null) {
      options = {};
    }
    if (_.isFunction(fn)) {
      if (path) {
        _.extend(options, {
          path: path
        });
      }
      (r = this.reactive(fn, options))();
      return r;
    } else {
      return this.get(path, options);
    }
  };

  d.join = function() {
    return _.chain(arguments).toArray().flatten().compact().filter(function(p) {
      return _.isString(p);
    }).map(function(p) {
      return d.trim(p);
    }).value().join(".");
  };

  d.split = function(path, base) {
    path = d.trim(path);
    if (path === "@") {
      path = base;
    } else if (/^\$/.test(path)) {
      path = path.replace(/^\$\.?/, "");
    } else if (base) {
      path = d.join(base, path);
    }
    if (/^\$/.test(path)) {
      path = path.replace(/^\$\.?/, "");
    }
    return _.compact(this._keysplit(path));
  };

  d.trim = function(str, sep) {
    var len, ss;
    if (sep == null) {
      sep = ".";
    }
    len = sep.length;
    ss = function() {
      return String.prototype.substr.apply(str, arguments);
    };
    while (ss(0, len) === sep) {
      str = ss(len);
    }
    while (ss(-1 * len) === sep) {
      str = ss(0, str.length - len);
    }
    return str;
  };

  d._parts = function(path) {
    var base, ctx;
    ctx = this.current;
    base = this.trim((ctx ? ctx.path : void 0) || "");
    return this.split(path, base);
  };

  d._keysplit = function(str, sep, avoid) {
    var i, len, part, parts, rawParts;
    if (sep == null) {
      sep = ".";
    }
    if (avoid == null) {
      avoid = "\\";
    }
    rawParts = str.split(sep);
    parts = [];
    i = 0;
    len = rawParts.length;
    while (i < len) {
      part = "";
      while (rawParts[i].slice(-1) === avoid) {
        part += rawParts[i++].slice(0, -1) + sep;
      }
      parts.push(part + rawParts[i]);
      i++;
    }
    return parts;
  };

  d._isBackboneData = function(obj) {
    return _.isObject(obj) && (obj instanceof Backbone.Model || obj instanceof Backbone.Collection);
  };

  d._complexToValue = function(obj) {
    var last;
    last = _.last(obj);
    if (!last.subpath.length) {
      return last.data;
    } else {
      return last.data.get(d.join(last.subpath));
    }
  };

  d._eventParse = function(str) {
    var attr, event, m, name;
    if (!(m = /^([^:]+)(?:\:(.*))?$/.exec(str))) {
      return;
    }
    event = m[0], name = m[1], attr = m[2];
    if (attr == null) {
      attr = "";
    }
    return {
      event: event,
      name: name,
      attr: attr
    };
  };

  d._pathOrPart = function(parts) {
    if (_.isString(parts)) {
      parts = d.split(parts);
    }
    return {
      path: d.join(parts),
      parts: parts
    };
  };

  d._isChildOf = function(parent, child, testSelf) {
    var bool;
    if (testSelf == null) {
      testSelf = false;
    }
    bool = ("" + parent + ".") === child.substr(0, parent.length + 1);
    if (testSelf) {
      bool = bool || parent === child;
    }
    return bool;
  };

}).call(this);
